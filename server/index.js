import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import { GoogleGenAI } from '@google/genai';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json({ limit: '50mb' }));

// --- ENDPOINTS ---

// 1. Generate Art - Using Official Google SDK Method
app.post('/api/generate-art', async (req, res) => {
    try {
        const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });
        const { sketchBase64, config, stylePrompt } = req.body;

        const finalPrompt = `
ROLE: MASTER NEURAL ARTIST.
MANDATORY_TARGET_STYLE: "${stylePrompt}"
USER INSTRUCTIONS: ${config.prompt || 'Execute a total stylistic transformation of the entire frame.'}
NEGATIVE CONSTRAINTS: ${config.negativePrompt || ''}, low resolution, artifacts, partial rendering, photo remnants.
`.trim();

        // Build contents array for the API
        const contents = [];

        // Add the text prompt
        contents.push({ text: finalPrompt });

        // Add reference image if provided
        if (config.referenceImage) {
            const refData = config.referenceImage.split(',')[1];
            contents.push({
                inlineData: {
                    mimeType: 'image/jpeg',
                    data: refData
                }
            });
        }

        // Add the sketch/canvas image
        if (sketchBase64) {
            const sketchData = sketchBase64.split(',')[1];
            contents.push({
                inlineData: {
                    mimeType: 'image/png',
                    data: sketchData
                }
            });
        }

        console.log('[Image Gen] Calling ai.models.generateContent...');

        // Use the CORRECT API method from official Google documentation
        const response = await ai.models.generateContent({
            model: config.model || 'gemini-2.5-flash-image',
            contents: contents,
        });

        console.log('[Image Gen] Response received, checking parts...');

        // Extract image from response.candidates[0].content.parts
        const parts = response.candidates?.[0]?.content?.parts;

        if (!parts || parts.length === 0) {
            console.log('[Image Gen] No parts in response:', JSON.stringify(response, null, 2));
            throw new Error("No content generated by model");
        }

        for (const part of parts) {
            if (part.text) {
                console.log('[Image Gen] Text response:', part.text);
            } else if (part.inlineData) {
                // This is the image data - it's already base64 encoded
                const imageData = part.inlineData.data;
                const mimeType = part.inlineData.mimeType || 'image/png';

                console.log('[Image Gen] SUCCESS! Image data length:', imageData.length);
                console.log('[Image Gen] MIME type:', mimeType);

                return res.json({
                    result: `data:${mimeType};base64,${imageData}`
                });
            }
        }

        // If we get here, no image was found in the response
        const textPart = parts.find(p => p.text);
        throw new Error(textPart?.text || "No image generated by model");

    } catch (err) {
        console.error('Generation Error:', err);
        return res.status(500).json({ error: err.message });
    }
});

// 2. Generate Video (Veo 3.1)
app.post('/api/generate-video', async (req, res) => {
    try {
        const ai = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY });
        const { config } = req.body;

        const videoParams = {
            model: config.model || 'veo-3.1-generate-preview',
            source: {
                prompt: config.prompt || 'Cinematic movement',
            },
            config: {
                aspectRatio: config.aspectRatio || '16:9',
                resolution: config.resolution || '720p',
                personGeneration: 'allow_adult' // Enable more creative freedom as per Veo 3.1 docs
            }
        };

        if (config.startingImage) {
            videoParams.source.image = {
                imageBytes: config.startingImage.split(',')[1],
                mimeType: 'image/jpeg'
            };
        }

        if (config.endingImage) {
            videoParams.config.lastFrame = {
                imageBytes: config.endingImage.split(',')[1],
                mimeType: 'image/jpeg'
            };
        }

        // Map ingredients to reference images for Image-based direction
        if (config.ingredients && Array.isArray(config.ingredients) && config.ingredients.length > 0) {
            videoParams.config.referenceImages = config.ingredients.map(imgData => ({
                image: {
                    imageBytes: imgData.split(',')[1],
                    mimeType: 'image/jpeg'
                },
                referenceType: 'asset' // Default to asset for character/object consistency
            }));
        }

        // 1. Kick off the generation
        let operation = await ai.models.generateVideos(videoParams);

        // 2. Poll for completion
        let attempts = 0;
        const maxAttempts = 30; // 30 * 5s = 150s (2.5 mins)

        while (!operation.done && attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 5000));
            operation = await ai.operations.getVideosOperation({ operation });
            attempts++;
            console.log(`Video generation progress: ${attempts}/${maxAttempts}`);
        }

        if (operation.done && operation.response?.generatedVideos?.[0]?.video) {
            const video = operation.response.generatedVideos[0].video;
            // Video object validation passed

            if (video.videoBytes) {
                return res.json({
                    videoBase64: video.videoBytes,
                    mimeType: video.mimeType || 'video/mp4'
                });
            }

            if (video.uri) {
                console.log('Fetching video from URI:', video.uri);
                try {
                    // The URI is a protected Google Cloud Storage resource, so we need to pass the API key
                    const response = await fetch(video.uri, {
                        headers: {
                            'x-goog-api-key': process.env.GEMINI_API_KEY
                        }
                    });
                    if (!response.ok) throw new Error(`Failed to fetch video: ${response.status} ${response.statusText}`);
                    const arrayBuffer = await response.arrayBuffer();
                    const base64 = Buffer.from(arrayBuffer).toString('base64');

                    console.log('Video fetched and encoded. Length:', base64.length);

                    return res.json({
                        videoBase64: base64,
                        mimeType: video.mimeType || 'video/mp4'
                    });
                } catch (fetchErr) {
                    console.error('Error fetching video from URI:', fetchErr);
                    throw fetchErr;
                }
            }
        }

        console.log('Operation Status:', JSON.stringify(operation, null, 2));
        throw new Error(operation.error?.message || "Video generation timed out or failed to produce a valid video object.");

    } catch (err) {
        console.error('Video Generation Error:', err);
        return res.status(500).json({ error: err.message });
    }
});

// 3. Download Endpoint - Forces correct filename with HTTP headers
app.post('/api/download', (req, res) => {
    try {
        const { base64Data, filename, mimeType } = req.body;

        if (!base64Data || !filename) {
            return res.status(400).json({ error: 'Missing base64Data or filename' });
        }

        // Convert base64 to buffer
        const buffer = Buffer.from(base64Data, 'base64');

        // Set headers to force download with correct filename
        res.setHeader('Content-Type', mimeType || 'application/octet-stream');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        res.setHeader('Content-Length', buffer.length);

        // Send the file
        res.send(buffer);

    } catch (err) {
        console.error('Download Error:', err);
        return res.status(500).json({ error: err.message });
    }
});

app.listen(PORT, () => {
    console.log(`Server running on port ${PORT}`);
});
